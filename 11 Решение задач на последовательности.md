Решение задач на последовательности
===================================

**Задача.** Дан непустой список чисел, найти в нём минимальный элемент.

Первая попытка решения. Перебрать все элементы в списке и для каждого
проверить — является ли этот элемент минимальным.

Шаблон для поиска элемента в последовательности:

```Python
def min(xs):
    for «элемент» in «последовательность»:
        if «элемент найден»:
            «что-то сделать с найденным»
            break
    else:
        «обработать случай, когда элемент не найден»

    «вернуть найденный минимальный»
```

Заметим, что список непустой и минимальный элемент по определению есть.
Поэтому ветка `else` при цикле `for` нам не нужна.

```Python
def min(xs):
    for «элемент» in «последовательность»:
        if «элемент найден»:
            «что-то сделать с найденным»
            break

    «вернуть найденный минимальный»
```

Конкретизируем псевдокод:

* «элемент» — просто переменная `x`, т.к. нам не важно, из чего состоит
  список. Если бы в списке были пары, кортежи, то мы бы распаковывали
  (т.е. `for x, y in …`).
* «последовательность» — `xs`.
* «что-то сделать с найденным» — ничего, т.к. нам его потом надо просто
  вернуть из функции.

```Python
def min(xs):
    for x in xs:
        if «элемент найден»:
            break

    return x
```

Что делать с «элемент найден» в пседокоде? Для этой цели мы определим
новую функцию, которая будет проверять — этот элемент минимальный в списке
или нет.

```Python
def min(xs):
    for x in xs:
        if is_minimal(x, xs):
            break

    return x

def is_minimal(x, xs):
    «истина, если элемент x минимальный»
```

Теперь нам надо написать функцию `is_minimal`. Что значит — «элемент минимальный»?
Это значит, что в списке _нет элемента, который будет меньше, чем проверяемый._

Т.е. это опять задача поиска элемента в последовательности. Нам нужно _попробовать_
найти элемент, который будет меньше, чем проверяемый. Если нашёлся — этот элемент
не минимальный.

```Python
def is_minimal(maybe_min, xs):
    «попробовать найти элемент в xs, который меньше, чем maybe_min»
    «вернуть успешность поиска»
```

Воспользуемся шаблоном поиска в последовательности:

```Python
def is_minimal(maybe_min, xs):
    for «элемент» in «последовательность»:
        if «элемент найден»:
            «обработать случай найденного»
            break
    else:
        «обработать случай не найденного»

    «вернуть успешность поиска»
```

Конкретизируем псевдокод:

```Python
def is_minimal(maybe_min, xs):
    for x in xs:
        if x < maybe_min:
            maybe_min_is_not_minimal = False
            break
    else:
        maybe_min_is_not_minimal = True

    return maybe_min_is_not_minimal
```

Программа целиком будет выглядеть так:

```Python
def min(xs):
    for x in xs:
        if is_minimal(x, xs):
            break

    return x

def is_minimal(maybe_min, xs):
    for x in xs:
        if x < maybe_min:
            maybe_min_is_not_minimal = False
            break
    else:
        maybe_min_is_not_minimal = True

    return maybe_min_is_not_minimal
```

Функции являются инструментом для декомпозиции программы: когда мы работаем
с одной функцией, _устройство_ остальных функций нас не интересует. Нас интересует
только результат работы других функций. Например, в `min` нас не интересует
устройство функции `is_minimal`, нам важно знать, что она делает. Если её содержимое
переписать, но сохранить поведение (проверяет, что некоторое значение меньше всех
элементов последовательности), функция `min` ничего не заметит.

**Приём.** Когда пишем программу и возникает потребность в некотором сложном
действии, то мы в месте для этого действия записываем вызов новой (ещё не существующей)
функции, а потом определяем функцию для этого действия.

Эту программу можно сократить:

```Python
def min(xs):
    for x in xs:
        if is_minimal(x, xs):
            return x

def is_minimal(maybe_min, xs):
    for x in xs:
        if x < maybe_min:
            return False

    return True
```

**Задача.** Дана последовательность чисел. Нужно подсчитать, сколько в ней
положительных, нулей и отрицательных чисел. Подсчёт должен выполняться функцией
`signs`, которая возвращает кортеж.

```Python
signs([1, 3, -5, 9, 0, 0, -43, 0, 0]) → (3, 4, 2)
```

Ход решения: перебираем элементы последовательности, для каждого из них проверяем,
какой знак он имеет. Увеличиваем соответствующий счётчик:

```Python
def signs(xs):
    pos = 0
    zeros = 0
    neg = 0
    for x in xs:
        if x > 0:
            pos += 1
        elif x == 0:
            zeros += 1
        else:
            neg += 1
    return (pos, zeros, neg)
```

**Задача.** Найти сумму чётных элементов последовательности.

Ход решения: перебрать все элементы последовательности, для каждого чётного
элемента увеличить сумму.

**Приём.** Переменная-аккумулятор. Если нужно найти сумму, произведение и т.д.
каких-то элементов, которых неизвестное количество:

    a + b + … + z
    a * b * … * z

заводим переменную-аккумулятор, которая будет накапливать результат. Начальным
её значением является нейтральный элемент, например `0` для сложения, `1` для
умножения, и к ней каждый следующий элемент добавляем.

Почему нейтральный элемент? Вот почему:

    (… ((0 + a) + b) + …) + z
    (… ((1 * a) * b) * …) * z

```Python
def even_sum(xs):
    res = 0
    for x in xs:
        if x % 2 == 0:
            res += x

    return res
```






