Файлы
=====

Файлы и папки, пути файлов
--------------------------

**Файл** — именованная облать данных на жёстком диске.
**Папка (каталог)** — именованная группа файлов.

**Текстовый файл** — файл, который только текст, т.е. последовательность
закодированных символов. Текстовый файл разбивается на строки при помощи
символов перевода строки `\n`. Примеры: файлы с расширением `.txt`, `.log`
(файлы журналов), исходные тексты программ `.py`, `.js`, `.cpp`, `.php`,
текст HTML, CSS (стили для HTML).

**Кодировка** — способ представления символов в виде байтов. Исторически
использовались однобайтовые кодировки, такие кодировки позволяли представлять
наборы из не более чем 256 различных знаков. Один байт может содержать только
256 разных значений, соответственно, каждое значение байта сопоставлялось
одному знаку.

Но на практике 256 знаков оказывается недостаточно для того, чтобы, например,
писать текст на разных языках. Был придуман **Юникод** — кодировка, включающая
в себя все возможные символы всех алфавитов, знаков пунктуации, математических
знаков, пиктограмм, и, в последние годы, даже смайлики (эмодзи).

Очевидно, для представления этих символов одного байта недостаточно, символы
Юникода представляются в виде нескольких последовательных байт.

Наиболее распространённым способом кодирования Юникода служит кодировка **UTF-8**,
в которой одному знаку может соответствовать 1, 2, 3 или 4 последовательных
байта.

Кодировка **ASCII** — набор из 127 символов с кодами от 0 до 127, которая
включает управляющие символы (вроде перевода строки, табуляции и некоторых
других), основные знаки пунктуации, числа и латинские буквы. Управляющие
символы имеют коды 0…31, пробел — 32, дальше — печатные символы.

Первая половина кодов большинства однобайтовых кодировок совпадает с кодировкой
ASCII. Однобайтовые кодировки для русского языка:

* CP866 или кодировка MS-DOS. Сейчас используется в Windows в окне консоли
  по умолчанию. Её ещё называют кодировкой OEM.
* CP1251, Windows-1251 — кодировка Windows для графических приложений, её называют
  кодировкой ANSI.
* KOI-8R, кодировка, которая раньше была популярна в интернете и на UNIX-системах.

В кодировке UTF-8 символы из кодировки ASCII занимают один байт, символы кириллицы —
2 байта, какие-нибудь иероглифы и смайлики — 3, 4 байта.

**Двоичный файл** — файл, который не является текстовым. Примеры двоичных файлов:
картинки, звукозаписи, видео, исполнимые файлы с машинным кодом (.exe, .dll),
архивы, текстовые документы с форматированием (Microsoft Word).

**Путь к файлу** — список каталогов, которые нужно пройти, чтобы добраться до файла
в файловой системе. Путь к файлу — способ указать на файл в компьютере.

Путь бывает **относительным** либо **абсолютным**. Абсолютный путь задаётся
относительно корня файловой системы (папка, не имеющая родительской папки),
относительный — относительно текущего каталога. У выполняющейся программы есть текущий
каталог, обычно, это папка, из которой программа запущена.

Имена каталогов пути разделяются символом-разделителем. На Windows — это либо `/`,
либо `\` (они почти взаимозаменяемы). На Linux и macOS — это только символ `/`.

Внутри программ при указании пути на Windows можно использовать и `/`, и `\`,
но в командной строке допустим только `\`.

Полный путь к этому файлу на компьютере преподавателя:

    D:\Mazdaywik\Documents\Преподавание\MEGA\2021 весна\Основы программирования (Л4)\Лекция 27.04\Лекция 2021-04-27.md

Абсолютный путь начинается с имени корневого каталога. На Windows может быть несколько
корневых каталогов по числу доступных дисков, они имеют имена вида `C:\`, `D:\`, …
на старых компьютерах можно встретить диск `A:\` — дискета, на очень старых — `A:\`
и `B:\` — две дискеты.

На macOS и Linux корневой каталог обозначается как `/`.

* Если на Windows подключить флешку, для неё будет выбрана новая буква диска, например, `E:\`.
* Если подключить флешку на Linux, то она подключится как подпапка `/media/‹имя-флешки›`.
* Как на macOS, не знаю, должно быть примерно как на Linux, но вместо `/media` может
  быть другая папка.

Примеры абсолютных путей на Windows:

* `C:\Windows\notepad.exe`
* `C:\Program Files\Python\Python.exe`
* `D:\Documents\Отчёт.docx`
* `D:/Documents/numbers.csv` — такой путь можно использовать внутри Python’а,
  но могут быть проблемы в командной строке.
  `f = open('D:/Documents/numbers.csv')

Примеры абсолютных путей на macOS или Linux:

* `/bin/bash`
* `/usr/bin/python3`
* `/home/username/Documents/Отчёт.odt`
* `/home/username/Documents/numbers.csv`

В относительных путях допустимы имена папок `.` и `..`, обозначающие, соответственно,
текущую папку (используется редко) и родительскую папку (в смысле, родительскую
для текущей).

Примеры относительных путей:

* `input.txt` — файл `input.txt` в текущей папке.
* `output\sorted.txt` — файл `sorted.txt` в подпапке `output` текущей папки,
  работает только на Windows.
* `output/sorted.txt` — аналогично, но будет работать на macOS и Linux.
* `../data/input.txt` — файл `input.txt` в папке `data`, которая лежит
  в родительской папке для текущей. Мы должны подняться на уровень выше, от текущей,
  там найти папку `data`, а в ней найти `input.txt`.
  Если текущей папкой была папка `D:\Documents\Project`, то этот относительный путь
  будет ссылаться на `D:\Documents\data\input.txt`.
* `../../Temp/file.tmp` — поднимаемся на два уровня выше, находим `Temp`, в ней `file.tmp`.
  Если текущей папкой является `D:\Documents\Project`, то мы попадём в `D:\Temp\file.tmp`.

Работа с файлами в Python
-------------------------

Для открытия файлов используется функция `open()`. Её аргументы:

     f = open(имя-файла)
     f = open(имя-файла, режим)
     f = open(имя-файла, encoding = кодировка)
     f = open(имя-файла, режим, encoding = кодировка)

Если указано только имя файла, то он открывается в режиме для чтения. Если кодировка
не указана, то выбирается кодировка по умолчанию, на macOS и Linux — UTF-8, на Windows —
Windows-1251. Поэтому рекомендуется, чтобы избежать проблем с кодировками,
на Windows явно указывать UTF-8:

    f = open(имя_файла, encoding = 'utf-8')
    f = open(имя_файла, режим, encoding = 'utf-8')

Указать кодировку UTF-8 никогда не помешает.

Возможные режимы файла:

* `"r"` — для чтения (по умолчанию), выбирается, если режим не указан.
* `"w"` — для перезаписи. Если файл существовал, то его содержимое стирается,
  т.е. его размер становится 0 байт, если не существовал, создаётся пустой
  и открывается.
* `"a"` — для дозаписи (append). Запись будет осуществляться в конец файла,
* `"r+"`, `"w+"`, `"a+"` — для чтения и записи.

Открытый файл нужно не забывать закрывать. Обычно Python сам закрывает файлы,
но не всегда. Для закрытия файла нужно или присвоить переменной, где хранится
объект файла, новое значение (например, `None`), либо вызвать метод `close()`:

    f = open('input.txt')
    …чтение файла…
    f = None

    f = open('input.txt')
    …чтение файла…
    f.close()

Если файл не закрыть, то на Windows операции с ним будут заблокированы,
например, файл удалить будет нельзя, будет выскакивать ошибка.

Опаснее не закрывать файлы, открытые на запись — часть данных может потеряться.
Записываемые данные буферизуются: накапливаются в оперативной памяти, а когда
буфер заполняется, записываются на диск. Запись на диск — относительно медленная
операция, поэтому имеет смысл её откладывать и записывать данные большими
порциями.

### Операции чтения и записи

Объект файла рассматривается как последовательность строк, т.е. его содержимое
можно читать в цикле `for`:

    f = open('input.txt')
    for line in f:
        line = line.rstrip()
        print(line)
    f.close()

Строки, которые в этом случае читаются из файла, заканчиваются на символ перевода
строки `\n`, поэтому для удобства работы их надо обрезать при помощи метода `rstrip()`.

Однако, есть специальные методы для чтения.

    s1 = f.read(n)
    s2 = f.read()

Метод `read(n)` читает `n` следующих символов из файла. При этом, если в файле
осталось менее `n` символов, то прочитается всё, что осталось. Если достигнут конец
файла, то прочитается пустая строка.

Если метод `read()` вызвать без параметров, то читается весь файл до конца. Если файл
небольшой (условно, меньше мегабайта), то прочесть весь файл можно. Если большой,
то памяти для файла может не хватить.

    line = f.readline()

Метод считывает очередную строку. Строка обычно заканчивается на знак перевода строки,
который можно срезать при помощи `rstrip()`.

    lines = f.readlines()

Метод `readlines()` считывает все строки в список, список размещается в оперативной
памяти. Тонкое отличие:

    for line in f:              #1
        …

    for line in f.readlines():  #2
        …

В первом случае файл будет читаться по мере перебора строк. Во втором случае — весь
файл будет прочитан целиком, в цикле `for` будет перебираться содержимое списка.

    >>> f = open('nul')
    >>> f.readline()
    ''
    >>> f.readlines()
    []
    >>> f.read()
    ''
    >>> f.close()

Файл `nul` — пустой файл, неявно присутствующий в любой папке на Windows. На Linux
и macOS такой же пустой файл находится по пути `/dev/null`. В этот файл можно писать,
но он всё равно останется пустым — чёрная дыра для операций записи.

    >>> f = open('nul', 'w')
    >>> f.write('hello')
    5
    >>> f.close()
    >>> f = open('nul')
    >>> f.read()
    ''
    >>> f.close()

Запись в файл осущетсвляется методом `write()`

    n = f.write(s)

Аргументом функции является строка, функция возвращает число записанных символов.

Также для записи в файл можно использовать функцию `print()` с дополнительным
параметром `file`:

    print('Hello', 42, file = f)

**Важно!** При использовании IDLE текущим каталогом является каталог, куда сохранён
исходный файл программы.