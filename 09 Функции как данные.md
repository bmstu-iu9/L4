Функции как данные, продолжение про итераторы
=============================================

Функции как данные
------------------

**Функции в языке Python** являются полноправными данными: их можно присваивать
переменным, передавать как параметры в другие функции, возвращать из других
функций, класть в структуры данных и т.д.

**Пример.** Создадим список из нескольких тригонометрических функций:

    >>> import math
    >>>> trig = [math.sin,
                 math.cos,
                 math.tan]
    >>> trig[1](0)
    1.0

В последней строке вывелось `1.0`, т.к. в `trig[1]` находится функция косинуса.

Список параметров в круглых скобках можно приписывать не только к имени,
но и к любому выражению. В примере выше мы его приписали к индексации списка:
`trig[1](0)`.

### Условное выражение

Ранее на лекции мы рассматривали условный оператор вида

    if ‹...›:
        ....
    elif ‹...›:
        ....
    else:
        ....

Но есть в Python и другой синтаксис, который позволяет осуществлять ветвления
и внутри выражений:

    ‹выражение-когда-True› if ‹условие› else ‹выражение-когда-False›

Пример:

    >>> x = 10
    >>> 100 if x > 5 else 500
    100

Здесь условие это `x > 5`, выражение, когда `True` — `100`, выражение, когда
`False` — `500`. Соответственно, сначала вычисляется условие, а потом либо
выражение перед `if`, либо выражение после `else`.

Условное выражение — выражение, которое, как и любое другое, порождает
значение, его можно присвоить переменной:

    >>> x = 3
    >>> y = 100 if x > 5 else 500
    >>> y
    500

В этом примере условие `x > 5` ложное, поэтому вычисляется вторая ветка `500`,
результат присваивается переменной `y`.

### Возвращаемся к функциям как данным

**Пример.** Пусть нам надо вычислить значение `sin(x)`, когда `x`
неотрицательный, `cos(x)` в противоположном случае.

    >>> y = math.sin(x) if x >= 0 else math.cos(x)

Т.к. сама функция является значением, вызов функции можно вынести за скобки:

    >>> y = (math.sin if x >= 0 else math.cos)(x)

Выражение в скобках выбирает функцию, затем мы эту функцию вызываем — к скобкам
приписан `(x)` — список аргументов функции.

Функцию, которая была в скобках, можно присвоить переменной:

    >>> f = math.sin if x >= 0 else math.cos
    >>> y = f(x)

В переменную `f` кладётся либо синус, либо косинус, в зависимости от знака `x`.
Затем функцию в переменной `f` вызываем.

Выражения `math.sin` и `math.cos` возвращают объекты функций, которые потом
будут вызываться.

### `def` — это оператор присваивания! (своеобразный)

**Оператор присваивания** — это оператор, который кладёт в переменную некоторое
значение. Если переменная ранее не была определена, то оператор присваивания
её создаёт.

    >>> z = 5

Здесь оператор присваивания создал переменную `z` и присвоил ей (положил в неё)
целое число `5`.

    >>> z = z + 10

Этот оператор присваивания положил в уже существующую переменную целое
число `15`. Переменная `z` ранее уже существовала.

А теперь — внимание! `def` — это оператор создания новой функции, который
одновременно является оператором присваивания. Он порождает новую функцию
и _присваивает её_ переменной с указанным именем. Т.е.

    def ‹имя›(‹параметры›):
        ‹тело функции›

Этот оператор создаст функцию с указанными параметрами и телом и _присвоит её
переменной с именем `‹имя›`._ Т.е. `‹имя›` — это самая обычная переменная,
в которой теперь лежит объект функции.

    def square(x):
        return x*x

    erauqs = square

Это две равнправные переменные, содержащие одну и ту же функцию. Иначе говоря,
одна функция имеет два псевдонима: `square` и `erauqs`.

Если мы определили функцию при помощи `def`, то указанной переменной можно
переприсвоить значение, это допустимо в Python:

    import math

    def square(x):
        return x**2

    print(square(0))
    square = math.cos
    print(square(0))

Эта программа напечатает сначала `0` (квадрат нуля), потом `1.0` (косинус нуля).

Именами переменных являются и встроенные функции, поэтому их можно случайно
потерять:

    >>> max([1, 3, 2])
    3
    >>> max = 100500
    >>> max([1, 3, 2])
    ‹ОШИБКА! Нельзя вызвать целое число 100500›

Ещё пример на оператор присваивания `def`:

    if x > 0:
        def f(y):
            return y**2
    else:
        def f(y):
            return y**3

Здесь переменной `f` будет присвоена функция. В случае положительного `x` —
присвоена функция, возвращающая квадрат числа, нуля или отрицательного —
возвращающая куб числа.

По смыслу этот пример кода близок к

    if x > 0:
        f = 2
    else:
        f = 3

только переменной `f` присваиваются не разные числа, а разные функции.

Таким образом, оператор `def` может встречаться в любом месте программы
и по смыслу он эквивалентен оператору присваивания, кладущему в соответствующую
переменную функцию. Оператор `def` может находиться и внутри условных операторов,
и внутри функций, и внутри циклов и т.д. Т.е. функции можно создавать внутри
других функций.

### Безымянные функции, `lambda`

В Python можно создать функцию и без одновременного присвоения переменной.
Тело такой функции может состоять только из одного выражения и по смыслу она
эквивалентна функции, тело которой состоит из единственного `return`’а.

Синтаксис:

     lambda ‹параметры›: ‹выражение›

По смыслу эквивалентно функции, создаваемой оператором `def`, но без присвоения

     def ????(‹параметры›):
         return ‹выражение›

Полученную безымянную функцию можно присвоить переменной, вернуть из `return`’а,
передать параметром функции, положить в контейнер (например, список или словарь)
и так далее.

**Пример.** Создадим список из функций, возвращающих степени числа:

    >>> powers = [lambda x: 1,
                  lambda x: x,
                  lambda x: x*x,
                  lambda x: x*x*x]
    >>> powers[2](7)
    49
    >>> powers[0](7)
    1

Действительно, 7⁰ = 1, 7² = 49.

**Пример.** Безымянные функции могут быть параметрами безымянных функций:

    >>> (lambda f: lambda x: f(f(x)))(lambda a: a*a)(2)
    16
    >>> (lambda f: lambda x: f(f(x)))(lambda a: a*a)(3)
    81

Встроенные функции, принимающие функции
---------------------------------------

Ряд встроенных функций и методов встроенных типов данных могут принимать функции
как параметры. Как правило, в них передают безымянные функции («лямбды»),
но можно передавать и любые другие функции.

### Функция `map(f, xs, ...)`

Функция `map` принимает функцию `n` аргументов и `n` итерируемых объектов,
возвращает итератор. Рассмотрим сначала простой случай, когда итерируемый
объект один:

    map(func, xs)

Итератор, возвращаемый `map`, будет выдавать значения `func(xs[0])`,
`func(xs[1])`, `func(xs[2])` и т.д., пока `xs` не исчерпается.

Пример. Вычислим квадраты чисел от 0 до 9. Поскольку `map` возвращает
итератор, чтобы увидеть все значения обернём вызов в список:

    >>> list(  map(lambda x: x**2, range(10))  )
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

В роли функции испльзовалась безымянная функция `lambda x: x**2`, возвращающая
квадрат числа, исходная последовательность создавалась при помощи `range`.

В случае нескольких аргументов функция `map` сочетает в себе свойства `zip`,
берёт по одному значению из каждого источника и вызывает функцию
с соответствующими аргументами.

    >>> list(  map(lambda x, y: x*y,  [2, 3, 5, 7, 11], [13, 17, 19, 23])  )
    [26, 51, 95, 161]

Аргументом `map` не обязательно может быть лямбда:

    >>> list(  map(len, ['Quick', 'brown', 'fox', 'jumps', 'over', 'dog'])  )
    [5, 5, 3, 5, 4, 3]
    >>> '+'.join(  map(str, [2, 3, 5, 7, 11, 13])  )
    '2+3+5+7+11+13'

### Ключи сортировки для `list.sort`, `sorted`, `max` и `min`
Метод списка `.sort` и встроенные функции `sorted`, `max` и `min` при сортировке
и нахождении наибольшего (или наименьшего) значений сравнивают значения при
помощи операций `<` или `>`, используют сортировку по умолчанию.

Однако, иногда нужно или сортировать данные по какому-нибудь другому критерию,
или вообще для сортируемых данных не определена операция сравнения. В этом
случае в эти функции передаётся ключ сортировки — функция, вычисляющая значение,
по которой будет выполняться сортировка.

Как осуществляется сортировка по умолчанию:

* Числа (целые и вещественные) сортируются по значению.
* Строки сортируются в лексиконографическом порядке: сначала сравниваются первые
  символы, выбирается чей код меньше. Если они равны, аналогично просматриваются
  вторые символы, третьи и т.д. Если начало одной строки целиком совпадает
  с другой, то меньшей считается более короткая. В общем, принцип аналогичен
  сортировке слов в обычных (бумажных) словарях по алфавиту, поэтому она
  и называется _лексиконографической._
* Кортежи и списки сортируются сортируются аналогично строкам
  в лексиконографическом порядке.
* Остальные типы данных, как правило, не упорядочены.













