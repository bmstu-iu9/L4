Лекция 1. Списковые включения
=============================

**Списковые включения** (list comprehensions, списковые выражения) — синтаксис,
позволяющий преобразовывать данные, представленные в виде итераторов или
итерируемых объектов.

Списковые включения есть в различных языках программирования, кроме Python’а
это, например, Haskell, Erlang, C# (так называемый Linq), Ruby. Вариантом
списковых включений можно считать оператор `SELECT` в SQL — языке запросов
к базам данных.

Списковые включения могут порождать итераторы либо контейнеры.


Списковое включение для итератора
---------------------------------

Базовый синтаксис построения итератора:

    (‹выражение с переменной ‹ПЕРЕМ››  for ‹ПЕРЕМ› in ‹ИСТОЧНИК›)

Здесь `‹ПЕРЕМ›` — имя переменной, `‹ИСТОЧНИК›` — некоторый итерируемый объект
(список, строка, `range`, итератор какой-нибудь и т.д.), `‹выражение …›` —
некоторое выражение.

Итератор будет запрашивать из источника очередное значение, класть его
в переменную `‹ПЕРЕМ›` и вычислять значение выражения. По сути это эквивалент
вызова

    map(lambda ‹ПЕРЕМ›: ‹выражение с переменной ‹ПЕРЕМ››, ‹ИСТОЧНИК›)

**Примеры:**

    # Квадраты натуральных чисел:
    squares = (x**2  for x  in [1, 2, 3, 4, 5, 6])

    print(*squares)          # Напечатает 1, 4, 9, 16, 25, 36

    # Длины слов в строке:
    lengths = (len(w)  for w  in 'Quick brown fox jumps over the dog'.split())

    print(*lengths)          # Напечатает 5 5 3 5 4 3 3

В первом примере в переменную `x` по очереди будут класться числа из списка,
для каждого числа будет вычисляться квадрат.

Во втором примере метод `.split()` разобьёт строку по пробелам на слова —
получится список слов

    ['Quick', 'brown', 'fox', 'jumps', 'over', 'the', dog']

Каждое из слов будет по очереди класться в переменную `w`, итератор будет
возвращать значение `len(w)` (т.е. длину слова в переменной `w`) для каждого
из слов строки.

Для того, чтобы напечатать все значения, которые формирует итератор, мы
используем вызов `print(*‹итератор›)` — из итератора будут извлечены все
значения и переданы как аргументы функции `print()`.

Итератор, сформированный таким синтаксисом, **ленивый,** т.е. вычисляет ровно
стролько значений, сколько мы у него попросим.

В списковом включении можно использовать и условия для фильтрации значений.
Синтаксис:

    (‹выражение›  for ‹ПЕРЕМ›  in ‹ИСТОЧНИК›  if ‹условие›)

Здесь

* `‹выражение›` — некоторое выражение с переменной `‹ПЕРЕМ›`,
* `‹ПЕРЕМ›` — имя переменной,
* `‹ИСТОЧНИК›` — итерируемый объект (контейнер, `range`, другой итератор),
* `‹условие›` — логическое выражение с переменной `‹ПЕРЕМ›`.

Семантика. Вычисляются только те выражения, для которых логическое выражение
после `if` оказалось истинным. Эта конструкция сочетает в себе и поведение
функции `filter`, и функции `map`. Аналог:

    map(lambda ‹ПЕРЕМ›: ‹выражение›,
        filter(lambda ‹ПЕРЕМ›: ‹условие›, ‹ИСТОЧНИК›))

**Пример.** Для данного списка чисел вычислим квадраты только чётных чисел.

    >>> xs = [1, 2, 3, 4, 5, 6, 7, 8]
    >>> squares = (x**2  for x in xs  if x % 2 == 0)
    >>> squares
    <generator object ...>
    >>> list(squares)
    [4, 16, 36, 64]


Круглые скобки вокруг спискового включения обязательны, без них получим
синтаксическую ошибку:

    >>> squares = x**2  for x in xs  if x % 2 == 0
    SyntaxError: invalid syntax

Однако, если списковое включение является аргументом функции, то скобки можно
не писать:

    >>> sum(x**2  for x in xs  if x % 2 == 0)
    120


Списковые включения для контейнеров
-----------------------------------

Выше мы показали, как породить итератор (т.н. «генератор»), генерирующий набор
значений. Но итератор — вещь одноразовая (прочитать можно один раз) и ленивая
(значения порождаются в процессе чтения, потому он и «генератор»). Часто бывает
нужно породить контейнер (список, словарь, множество) из некоторых значений.

Можно порождать контейнер в два шага — породить генератор и вызвать конструктор
контейнера. Например, список квадратов целых чисел:

    >>> numbers = [1, 2, 3, 4, 5, 6]
    >>> squares_iter = (x**2  for x in xs)
    >>> squares = list(squares_iter)

Генератор, конечно, можно записать внутрь конструктора списка:

    >>> numbers = [1, 2, 3, 4, 5, 6]
    >>> squares = list( (x**2  for x in xs) )

Скобки, конечно, можно опустить:

    >>> numbers = [1, 2, 3, 4, 5, 6]
    >>> squares = list(x**2  for x in xs)

Но в Python для этой цели есть специальный компактный синтаксис:

    >>> numbers = [1, 2, 3, 4, 5, 6]
    >>> squares = [x**2  for x in xs]

А именно, если списковое включение записать не в круглых, а квадратных скобках,
то построится не ленивый одноразовый генератор, а список из данных значений.

Аналогично, можно породить и множество (контейнер без повторяющихся значений):

    >>> numbers = [1, 2, 3, 4, 5, 6]
    >>> squares = {x**2  for x in xs}
    >>> squares
    {64, 1, 4, 36, 9, 16, 49, 25}

В отличие от списка, элементы во множестве не упорядочены.

Можно порождать и словари:

    >>> phrase = 'The quick brown fox jumps over the lazy dog'
    >>> words = phrase.split()
    >>> word_lens = { w : len(w)  for w in words }
    >>> word_lens
    {'The': 3, 'quick': 5, 'brown': 5, 'fox': 3, …}
    >>> word_lens['fox']
    3
    >>> word_lens['brown']
    5

В отличие от множества, элемент словаря (пара «ключ-значение») описывается
с использованием знака `:`.


