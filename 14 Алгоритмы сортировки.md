Алгоритмы сортировки
====================

Сортировка пузырьком
--------------------

Кратко алгоритм можно описать следующим образом:

* Многократно пробегаем по массиву. Если видим пару соседних элементов, таких
  что больший предшествует меньшему, меняем их местами.
* Повторяем проходы по массиву до тех пор, пока массив не отсортируется.

Допустим, у нас есть следующий список:

    [1, 2, 1, 5, 10, 12]

Первый проход:

    [1, 2, 1, 5, 10, 12]
     ↑  ↑

Первая пара отсортирована, ничего с ними не делаем, сдвигаемся:

    [1, 2, 1, 5, 10, 12]
        ↑  ↑

Здесь уже больший (`2`) предшествует меньшему (`1`), их нужно обменять местами:

    [1, 1, 2, 5, 10, 12]
        ↑  ↑

Сдвигаемся на следующую пару:

    [1, 1, 2, 5, 10, 12]
           ↑  ↑

Ничего не делаем, т.к. меньший (`2`) предшествует большему (`5`), сдвигаемся:

    [1, 1, 2, 5, 10, 12]
              ↑  ↑
    [1, 1, 2, 5, 10, 12]
                 ↑   ↑

Первый проход закончен. Получился отсортированный список.

Пример получился неинтересным, рассмотрим какой-нибудь другой пример:

Первый проход:

    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ↑  ↑
    [3, 9, 5, 8, 6, 7, 4, 1, 0, 2]
        ↑  ↑
    [3, 5, 9, 8, 6, 7, 4, 1, 0, 2]
           ↑  ↑
    [3, 5, 8, 9, 6, 7, 4, 1, 0, 2]
              ↑  ↑
    [3, 5, 8, 6, 9, 7, 4, 1, 0, 2]
                 ↑  ↑
    [3, 5, 8, 6, 7, 9, 4, 1, 0, 2]
                    ↑  ↑
    [3, 5, 8, 6, 7, 4, 9, 1, 0, 2]
                       ↑  ↑
    [3, 5, 8, 6, 7, 4, 1, 9, 0, 2]
                          ↑  ↑
    [3, 5, 8, 6, 7, 4, 1, 0, 9, 2]
                             ↑  ↑
    [3, 5, 8, 6, 7, 4, 1, 0, 2, 9]
                             ↑  ↑

За первый проход элемент `9` занял своё «законное» место. Второй проход:

    [3, 5, 8, 6, 7, 4, 1, 0, 2, 9]
     ↑  ↑
    [3, 5, 8, 6, 7, 4, 1, 0, 2, 9]
        ↑  ↑
    [3, 5, 8, 6, 7, 4, 1, 0, 2, 9]
           ↑  ↑
    [3, 5, 6, 8, 7, 4, 1, 0, 2, 9]
              ↑  ↑
    [3, 5, 6, 7, 8, 4, 1, 0, 2, 9]
                 ↑  ↑
    [3, 5, 6, 7, 4, 8, 1, 0, 2, 9]
                    ↑  ↑
    [3, 5, 6, 7, 4, 1, 8, 0, 2, 9]
                       ↑  ↑
    [3, 5, 6, 7, 4, 1, 0, 8, 2, 9]
                          ↑  ↑
    [3, 5, 6, 7, 4, 1, 0, 2, 8, 9]
                             ↑  ↑

За второй проход предпоследний элемент занял правильное место. Третий проход:

    [3, 5, 6, 7, 4, 1, 0, 2, 8, 9]
     ↑  ↑
    [3, 5, 6, 7, 4, 1, 0, 2, 8, 9]
        ↑  ↑
    [3, 5, 6, 7, 4, 1, 0, 2, 8, 9]
           ↑  ↑
    [3, 5, 6, 7, 4, 1, 0, 2, 8, 9]
              ↑  ↑
    [3, 5, 6, 4, 7, 1, 0, 2, 8, 9]
                 ↑  ↑
    [3, 5, 6, 4, 1, 7, 0, 2, 8, 9]
                    ↑  ↑
    [3, 5, 6, 4, 1, 0, 7, 2, 8, 9]
                       ↑  ↑
    [3, 5, 6, 4, 1, 0, 2, 7, 8, 9]
                          ↑  ↑
    [3, 5, 6, 4, 1, 0, 2, 7, 8, 9]
                             ↑  ↑

Четвёртый проход:

    [3, 5, 6, 4, 1, 0, 2, 7, 8, 9]
     ↑  ↑
    [3, 5, 6, 4, 1, 0, 2, 7, 8, 9]
        ↑  ↑
    [3, 5, 6, 4, 1, 0, 2, 7, 8, 9]
           ↑  ↑
    [3, 5, 4, 6, 1, 0, 2, 7, 8, 9]
              ↑  ↑
    [3, 5, 4, 1, 6, 0, 2, 7, 8, 9]
                 ↑  ↑
    [3, 5, 4, 1, 0, 6, 2, 7, 8, 9]
                    ↑  ↑
    [3, 5, 4, 1, 0, 2, 6, 7, 8, 9]
                       ↑  ↑
    [3, 5, 4, 1, 0, 2, 6, 7, 8, 9]
                          ↑  ↑
    [3, 5, 4, 1, 0, 2, 6, 7, 8, 9]
                             ↑  ↑

Пятый проход:

    [3, 5, 4, 1, 0, 2, 6, 7, 8, 9]
     ↑  ↑
    [3, 5, 4, 1, 0, 2, 6, 7, 8, 9]
        ↑  ↑
    [3, 4, 5, 1, 0, 2, 6, 7, 8, 9]
           ↑  ↑
    [3, 4, 1, 5, 0, 2, 6, 7, 8, 9]
              ↑  ↑
    [3, 4, 1, 0, 5, 2, 6, 7, 8, 9]
                 ↑  ↑
    [3, 4, 1, 0, 2, 5, 6, 7, 8, 9]
                    ↑  ↑
    [3, 4, 1, 0, 2, 5, 6, 7, 8, 9]
                       ↑  ↑
    [3, 4, 1, 0, 2, 5, 6, 7, 8, 9]
                          ↑  ↑
    [3, 4, 1, 0, 2, 5, 6, 7, 8, 9]
                             ↑  ↑

Шестой проход:

    [3, 4, 1, 0, 2, 5, 6, 7, 8, 9]
     ↑  ↑
    [3, 4, 1, 0, 2, 5, 6, 7, 8, 9]
        ↑  ↑
    [3, 1, 4, 0, 2, 5, 6, 7, 8, 9]
           ↑  ↑
    [3, 1, 0, 4, 2, 5, 6, 7, 8, 9]
              ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                 ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                    ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                       ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                          ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                             ↑  ↑

Седьмой проход:

    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
     ↑  ↑
    [1, 3, 0, 2, 4, 5, 6, 7, 8, 9]
        ↑  ↑
    [1, 0, 3, 2, 4, 5, 6, 7, 8, 9]
           ↑  ↑
    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
              ↑  ↑
    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
                 ↑  ↑
    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
                    ↑  ↑
    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
                       ↑  ↑
    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
                          ↑  ↑
    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
                             ↑  ↑

Восьмой проход:

    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
     ↑  ↑
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        ↑  ↑
    . . .
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
                             ↑  ↑

Больше проходов не нужно.

Вопрос первый? Сколько нужно проходов алгоритму в худшем случае?

Число проходов равно `N−1`, где `N` — число элементов в списке. Каждый
проход ставит на `k−1`-е место `k`-й элемент по размеру. (Почему на `k−1`-е?
Потому что ячейки в списке в Python нумеруются с нуля). Т.е. первый
проход поставит на последнее (`N−1`) место самый большой элемент (`N`-й),
второй — на предпоследнее (`N−2`) место `N−1` по возрастанию и т.д.
Соответственно, `N−1`-й проход поставит на своё место 1-й элемент, и при
этом неизбежно на своём месте окажется 0-й элемент.

Таким образом, мы можем написать первую версию алгоритма:

```python
def bubble_sort(xs):
    N = len(xs)

    # перебираем все проходы
    for p in range(N-1):
        # перебираем все пары соседних элементов,
        # pos — номер первого элемента пары
        for pos in range(N-1):
            # меняем местами элементы, если порядок нарушен
            if xs[pos] > xs[pos + 1]:
                xs[pos], xs[pos + 1] = xs[pos + 1], xs[pos]
```

Можно ли рассмотренный алгоритм как-то ускорить?

Рассмотрим один из проходов алгоритма, например, шестой:

    [3, 4, 1, 0, 2, 5, 6, 7, 8, 9]
     ↑  ↑
    [3, 4, 1, 0, 2, 5, 6, 7, 8, 9]
        ↑  ↑
    [3, 1, 4, 0, 2, 5, 6, 7, 8, 9]
           ↑  ↑
    [3, 1, 0, 4, 2, 5, 6, 7, 8, 9]
              ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                 ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                    ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                       ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                          ↑  ↑
    [3, 1, 0, 2, 4, 5, 6, 7, 8, 9]
                             ↑  ↑

После того, как `4` встала на своё место, последующие шаги прохода стали
избыточными: последующие элементы уже отсортированы. Их даже просматривать
не надо. Таким образом, с каждым проходом можно верхнюю границу уменьшать
на единицу.

```python
def bubble_sort(xs):
    N = len(xs)
    upper = N-1

    for p in range(N-1):
        for pos in range(upper):
            if xs[pos] > xs[pos + 1]:
                xs[pos], xs[pos + 1] = xs[pos + 1], xs[pos]

        upper -= 1
```

В переменной `upper` находится верхняя граница просмотра списка на проходе.

На первом проходе мы теперь пробегаем по-прежнему все пары, на втором — все
пары, кроме последней, на третьем — все пары, кроме последней и предпоследней
и т.д.

Заметим, что после последнего прохода `upper` равна нулю. Поэтому вместо
счётчика проходов можно проверять условие `upper > 0`:

```python
def bubble_sort(xs):
    N = len(xs)
    upper = N-1

    while upper > 0:
        for pos in range(upper):
            if xs[pos] > xs[pos + 1]:
                xs[pos], xs[pos + 1] = xs[pos + 1], xs[pos]

        upper -= 1
```

Можем дальше ускорить этот алгорим. Что будет, если на входе у нас уже
отсортированный список? Алгоритм будет делать `N−1` проходов, в каждом проходе
будет просматривать часть списка. И всё будет в холостую, т.к. ни одного
обмена уже не будет.

Если на некотором проходе у нас не произошло ни одного обмена, значит
и на последующих проходах обмены происходить не будут. Если не было ни одного
обмена, значит, список уже отсортирован. Последующие проходы тоже в нём ничего
не поменяют.

Поэтому мы можем отслеживать факт наличия обмена и если обменов не было,
прерывать внешний цикл.

```python
def bubble_sort(xs):
    N = len(xs)
    upper = N-1

    unsorted = True
    while upper > 0 and unsorted:
        # гипотеза о том, что список уже был отсортирован
        unsorted = False
        for pos in range(upper):
            if xs[pos] > xs[pos + 1]:
                xs[pos], xs[pos + 1] = xs[pos + 1], xs[pos]
                # обмен произошёл, гипотезу опровергаем:
                unsorted = True

        upper -= 1
```
Переменная `unsorted` — признак того, что список, вероятно, не отсортирован.
Внутри внешнего цикла мы делаем гипотезу, что список отсортирован (присваиваем
`False`). Если не было ни одного обмена — гипотеза подтверждается, на входе
прохода список уже был отсортирован, повторять проходы не надо. Если хотя бы
один обмен был, значит список может быть не отсортирован.

Если у нас обменов не было, значит у нас уже был отсортированный список, больше
выполнять проходы не нужно (они ничего не дадут, хоть и не испортят). Если хотя бы
один обмен был, то мы не знаем, список отсортированный или нет.


Сортировка выбором
------------------

Сканируем весь список. Находим наибольший элемент и ставим его в конец. Сканируем
весь список, кроме последнего элемента, находим наибольший, ставим его предпоследним.
Сканируем весь список, кроме последних двух, находим наибольший, ставим его третьим
с конца. Повторяем, пока не расставим все элементы.

    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ↑                           |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ^  ↑                        |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ^     ↑                     |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ^        ↑                  |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ^           ↑               |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ^              ↑            |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ^                 ↑         |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ^                    ↑      |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
     ^                       ↑   |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
                                ↑|

Среди просмотренных наибольший — 9. Ставим его в конец (обмениваем местами
с последним).

    [2, 3, 5, 8, 6, 7, 4, 1, 0, 9]
     ↑                        |
    [2, 3, 5, 8, 6, 7, 4, 1, 0, 9]
        ↑                     |
    . . .
    [2, 3, 5, 8, 6, 7, 4, 1, 0, 9]
              ^              ↑|

Наибольший — 8, обмениваем его местами с предпоследним.

    [2, 3, 5, 0, 6, 7, 4, 1, 8, 9]
                    ^      |

Повторяем дальше:

    [2, 3, 5, 0, 6, 1, 4, 7, 8, 9]
                 ^      |
    [2, 3, 5, 0, 4, 1, 6, 7, 8, 9]
           ^         |
    [2, 3, 1, 0, 4, 5, 6, 7, 8, 9]
                 ^|
    [2, 3, 1, 0, 4, 5, 6, 7, 8, 9]
        ^      |
    [2, 0, 1, 3, 4, 5, 6, 7, 8, 9]
     ^      |
    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
     ^   |
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      |

Получили отсортированный список.

Давайте писать программу на Python. У программы будет два вложенных цикла:
внешний цикл, который сдвигает границу между несортированной и сортированной
частями, и внутренний цикл, в котором мы будем искать очередной максимальный
элемент в несортированной части.

Граница сдвигается справа налево от `len(xs)` до `1`, т.к. в начале
несортированных элементов нет, а заканчиваем проходы, когда в несортированной
части остаётся один элемент.

Для перебора всех позиций границы удобнее всего использовать `range()`
с отрицательным шагом. В `range(start, limit, step)` предельная величина
`limit` в последовательность чисел не включается. Поэтому, чтобы перебрать
числа до `1`, мы указываем границу в `0`.

```python
def select_sort(xs):
    for sort_edge in range(len(xs), 0, -1):
        «выполняем проход сортировки»
```

Внутри прохода сортировки нам нужно найти позицию наибольшего элемента
в диапазоне индексов от `0` до `sort_edge`, включая `0` и исключая `sort_edge`.
Затем нужно обменять местами значения найденного максимального и элемента
в позиции `sort_edge−1`.

Мы уже рассматривали алгоритм поиска наибольшего значения в некоторой
последовательности. Идея его заключалась в том, что в переменную-аккумулятор
мы клали первый элемент последовательности, затем перебирали остальные и сравнивали
их со значением аккумулятора. Если очередной элемент оказывался больше значения
в аккумуляторе, то значение в аккумуляторе обновляли — присваивали большее.

Алгоритм поиска индекса наибольшего элемента аналогичен, только в аккумуляторе
должно находиться не само значение, а его индекс.

```python
def select_sort(xs):
    for sort_edge in range(len(xs), 0, -1):
        «находим позицию наибольшего элемента в диапазоне [0, sort_edge)»
        «обмениваем значения наибольшего и xs[sort_edge-1]»
```

Конкретизируем псевдокод:

```python
def select_sort(xs):
    for sort_edge in range(len(xs), 0, -1):
        # находим позицию наибольшего элемента в диапазоне [0, sort_edge)
        max_pos = 0
        for i in range(1, sort_edge):
            if xs[max_pos] < xs[i]:
                max_pos = i

        # обмениваем значения наибольшего и xs[sort_edge-1]
        xs[max_pos], xs[sort_edge - 1] = xs[sort_edge - 1], xs[max_pos]
```

Для отладки добавим печать в конце тела внешнего цикла (после обмена):

```python
def select_sort(xs):
    for sort_edge in range(len(xs), 0, -1):
        # находим позицию наибольшего элемента в диапазоне [0, sort_edge)
        max_pos = 0
        for i in range(1, sort_edge):
            if xs[max_pos] < xs[i]:
                max_pos = i

        # обмениваем значения наибольшего и xs[sort_edge-1]
        xs[max_pos], xs[sort_edge - 1] = xs[sort_edge - 1], xs[max_pos]
        print(xs)
```

В результате получили следующий вывод:

```
>>> xs = [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
>>> select_sort(xs)
[2, 3, 5, 8, 6, 7, 4, 1, 0, 9]
[2, 3, 5, 0, 6, 7, 4, 1, 8, 9]
[2, 3, 5, 0, 6, 1, 4, 7, 8, 9]
[2, 3, 5, 0, 4, 1, 6, 7, 8, 9]
[2, 3, 1, 0, 4, 5, 6, 7, 8, 9]
[2, 3, 1, 0, 4, 5, 6, 7, 8, 9]
[2, 0, 1, 3, 4, 5, 6, 7, 8, 9]
[1, 0, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> xs
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
```

Видно, что алгоритм делает лишний проход. Действительно, случай, когда
`sort_edge` равен `1`, рассматривать не надо. Мы ищем наибольший элемент
в пустом списке, что бессмысленно. Используемый алгоритм предлагает
позицию `0`, что совпадает с `sort_edge−1`, а значит элемент номер `0`
обменивается сам с собой.

Таким образом, последний проход лишний. Правильная программа будет иметь
вид (см `range()` в наружнем цикле):

```python
def select_sort(xs):
    for sort_edge in range(len(xs), 1, -1):
        # находим позицию наибольшего элемента в диапазоне [0, sort_edge)
        max_pos = 0
        for i in range(1, sort_edge):
            if xs[max_pos] < xs[i]:
                max_pos = i

        # обмениваем значения наибольшего и xs[sort_edge-1]
        xs[max_pos], xs[sort_edge - 1] = xs[sort_edge - 1], xs[max_pos]
```

Сравнение алгоритма сортировки пузырьком и сортировки выбором
-------------------------------------------------------------

Алгоритм сортировки пузырьком будет делать в среднем O(N²) операций обмена
и O(N²) операций сравнения.

Алгоритм сортировки выбором тоже требует O(N²) сравнений, но при этом делает
всего O(N) операций обмена.

Поэтому в общем случае, алгоритм сортировки выбором эффективнее алгоритма
сортировки пузырьком.

Однако, алгоритм сортировки выбором «жёсткий» в том смысле, что число проходов
внешнего и внутренего цикла одно и то же и не зависит от упорядочивания
элементов.

Алгоритм сортировки пузырьком, напротив, может делать меньше проходов, если
исходный список уже частично отсортирован. Так например, если список уже
отсортирован, то потребуется всего один проход, т.е. O(N) операций.


Сортировка вставками
--------------------

Этот алгоритм похож на предыдущий тем, что список делится на две части:
несортированную и сортированную. На каждом шаге точно также сортированная
часть увеличивается на 1 элемент, несортированная — соответственно уменьшается.

Разница в способе роста сортированной части. В алгоритме сортировки выбором
мы приписывали к сортированной части наибольший элемент из несортированных,
элементы сортированной части не переупорядочивали. При этом менялся порядок
элементов сотрированной части.

В алгоритме сортировки вставками мы будем действовать наоборот: сначала
перемещать границу: несортированная часть уменьшилась, сортированная увеличилась.
Но при этом может нарушится сортировка в сортированной части. Поэтому затем
восстанавливаем упорядоченность по возрастанию.

    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
                                 |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
                              |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
                           |
    [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]  ← сдвигаем границу
                        |

После очередного сдвига границы в «сотрированной части» нарушился порядок
сортировки. Восстанавливаем его:

    [9, 3, 5, 8, 6, 7, 4, 0, 1, 2]  ← восстанавливаем упорядоченность
                        |
    [9, 3, 5, 8, 6, 7, 4, 0, 1, 2]  ← сдвигаем границу
                     |
    [9, 3, 5, 8, 6, 7, 0, 1, 2, 4]  ← восстанавливаем упорядоченность
                     |
    [9, 3, 5, 8, 6, 7, 0, 1, 2, 4]  ← сдвигаем границу
                  |
    [9, 3, 5, 8, 6, 0, 1, 2, 4, 7]  ← восстанавливаем упорядоченность
                  |
    [9, 3, 5, 8, 6, 0, 1, 2, 4, 7]  ← сдвигаем границу
               |
    [9, 3, 5, 8, 0, 1, 2, 4, 6, 7]  ← восстанавливаем упорядоченность
               |
    [9, 3, 5, 8, 0, 1, 2, 4, 6, 7]  ← сдвигаем границу
            |
    [9, 3, 5, 0, 1, 2, 4, 6, 7, 8]  ← восстанавливаем упорядоченность
            |
    [9, 3, 5, 0, 1, 2, 4, 6, 7, 8]  ← сдвигаем границу
         |
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]  ← восстанавливаем упорядоченность
         |
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]  ← сдвигаем границу
      |
    [9, 0, 1, 2, 3, 4, 5, 6, 7, 8]  ← восстанавливаем упорядоченность
      |
    [9, 0, 1, 2, 3, 4, 5, 6, 7, 8]  ← сдвигаем границу
    |
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  ← восстанавливаем упорядоченность
    |

Самое интересное тут — как происходит восстановление упорядоченности.
Использовать рекурсивный вызов этого алгоритма сортировки мы тут не можем,
рекурсия зациклится. Значит, для восстановления порядка нужно применить
какой-то другой алгоритм сортировки.

Какой из алгоритмов сортировки нам нужно использовать, чтобы восстановить
порядок в отсортированной части?

Алгоритм сортировки выбором не подходит, поскольку он всегда выполняет
O(N²) операций: O(N) проходов по O(N) операций.

Алгоритм сортировки пузырьком адаптивный: он делает столько проходов,
сколько нужно для сортировки. Для частично упорядоченной последовательности
он может делать гораздо меньше, чем O(N) проходов.

В данном случае он вообще всегда будет делать только один проход, т.к.
одного прохода достаточно.

Таким образом, для восстановления упорядоченности мы можем делать один
проход сортировки пузырьком.

Когда вставляемый элемент займёт свою позицию, последующие шаги прохода
уже будут холостыми, т.к. дальнейший участок списка уже отсортирован.

    [9, 3, 5, 0, 1, 2, 4, 6, 7, 8]
         | ^  ^
    [9, 3, 0, 5, 1, 2, 4, 6, 7, 8]
         |    ^  ^
    [9, 3, 0, 1, 5, 2, 4, 6, 7, 8]
         |       ^  ^
    [9, 3, 0, 1, 2, 5, 4, 6, 7, 8]
         |          ^  ^
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]
         |             ^  ^         ← обмена не нужно
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]
         |                ^  ^      ← обмена не нужно
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]
         |                   ^  ^   ← обмена не нужно

После первого шага, не требующего обмена, проход сортировки пузырьком
можно остановить.

```python
def insert_sort(xs):
    «устанавливаем границу: сортированная часть пуста,
     несортированная охватывает весь список»

    «повторяем, пока не кончатся несортированные элементы»:
        «сдвигаем границу на одну позицию влево»
        «восстанавливаем упорядоченность в сортированной части»
```

Будем конкретизировать псевдокод. Граница будет храниться в переменной
`border`, диапазон `0 : border` (включая `0`, не включая `border`) будет
несортированной частью, диапазон `border : len(xs)` — сортированной.

```python
def insert_sort(xs):
    border = len(xs)
    # несортированная часть: xs[0 : border]
    # сортированная часть: xs[border : len(xs)]

    while border > 0:
        border -= 1
        «восстанавливаем упорядоченность в сортированной части»
```

Как мы обсудили выше, восстановление порядка будем делать одним проходом
сортировки пузырьком:

```python
def insert_sort(xs):
    border = len(xs)
    # несортированная часть: xs[0 : border]
    # сортированная часть: xs[border : len(xs)]

    while border > 0:
        border -= 1

        i = border
        j = border + 1
        while j < len(xs):
            if xs[i] > xs[j]:
                xs[i], xs[j] = xs[j], xs[i]
            i += 1
            j += 1
```

Здесь мы проходим по всем парам соседних элементов, `i` — левый сосед,
`j` — правый сосед. Если упорядоченность нарушается, меняем их местами.

Можно учесть, что `j` всегда равен `i + 1`, а значит для обозначения пары
нам достаточно одной переменной.


Как мы заметили выше, обмен здесь будет единственным, т.е. после первого
обмена циклы будут холостыми. Посмотрим ещё раз на пример:

    [9, 3, 5, 0, 1, 2, 4, 6, 7, 8]
         | ^  ^
    [9, 3, 0, 5, 1, 2, 4, 6, 7, 8]
         |    ^  ^
    [9, 3, 0, 1, 5, 2, 4, 6, 7, 8]
         |       ^  ^
    [9, 3, 0, 1, 2, 5, 4, 6, 7, 8]
         |          ^  ^
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]
         |             ^  ^         ← обмена не нужно
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]
         |                ^  ^      ← обмена не нужно
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]
         |                   ^  ^   ← обмена не нужно

```python
        i = border
        while i + 1 < len(xs):
            if xs[i] > xs[i + 1]:
                xs[i], xs[i + 1] = xs[i + 1], xs[i]
            i += 1
```

Чтобы прервать цикл после первого обмена, условие из `if` нужно перенести
в заголовок цикла:

```python
        i = border
        while i + 1 < len(xs) and xs[i] > xs[i + 1]:
            xs[i], xs[i + 1] = xs[i + 1], xs[i]
            i += 1
```

Целиком программа теперь выглядит так:

```python
def insert_sort(xs):
    border = len(xs)
    # несортированная часть: xs[0 : border]
    # сортированная часть: xs[border : len(xs)]

    while border > 0:
        border -= 1

        i = border
        while i + 1 < len(xs) and xs[i] > xs[i + 1]:
            xs[i], xs[i + 1] = xs[i + 1], xs[i]
            i += 1
```

Добавим отладочную печать:

```python
def insert_sort(xs):
    border = len(xs)
    # несортированная часть: xs[0 : border]
    # сортированная часть: xs[border : len(xs)]

    while border > 0:
        border -= 1

        print('before bubble sort pass', xs[0:border], xs[border:len(xs)])
        i = border
        while i + 1 < len(xs) and xs[i] > xs[i + 1]:
            xs[i], xs[i + 1] = xs[i + 1], xs[i]
            i += 1
        print(' after bubble sort pass', xs[0:border], xs[border:len(xs)])
    print(xs[0:border], xs[border:len(xs)])
```

Вывод программы:

```
>>> xs = [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
>>> insert_sort(xs)
before bubble sort pass [9, 3, 5, 8, 6, 7, 4, 1, 0] [2]
 after bubble sort pass [9, 3, 5, 8, 6, 7, 4, 1, 0] [2]
before bubble sort pass [9, 3, 5, 8, 6, 7, 4, 1] [0, 2]
 after bubble sort pass [9, 3, 5, 8, 6, 7, 4, 1] [0, 2]
before bubble sort pass [9, 3, 5, 8, 6, 7, 4] [1, 0, 2]
 after bubble sort pass [9, 3, 5, 8, 6, 7, 4] [0, 1, 2]
before bubble sort pass [9, 3, 5, 8, 6, 7] [4, 0, 1, 2]
 after bubble sort pass [9, 3, 5, 8, 6, 7] [0, 1, 2, 4]
before bubble sort pass [9, 3, 5, 8, 6] [7, 0, 1, 2, 4]
 after bubble sort pass [9, 3, 5, 8, 6] [0, 1, 2, 4, 7]
before bubble sort pass [9, 3, 5, 8] [6, 0, 1, 2, 4, 7]
 after bubble sort pass [9, 3, 5, 8] [0, 1, 2, 4, 6, 7]
before bubble sort pass [9, 3, 5] [8, 0, 1, 2, 4, 6, 7]
 after bubble sort pass [9, 3, 5] [0, 1, 2, 4, 6, 7, 8]
before bubble sort pass [9, 3] [5, 0, 1, 2, 4, 6, 7, 8]
 after bubble sort pass [9, 3] [0, 1, 2, 4, 5, 6, 7, 8]
before bubble sort pass [9] [3, 0, 1, 2, 4, 5, 6, 7, 8]
 after bubble sort pass [9] [0, 1, 2, 3, 4, 5, 6, 7, 8]
before bubble sort pass [] [9, 0, 1, 2, 3, 4, 5, 6, 7, 8]
 after bubble sort pass [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Видно, что один проход у нас лишний: самый первый. Т.к. сортированная
часть из одного элемента уже по определению отсортирована, а значит,
устанавливать `border` надо не в `len(xs)`, а на единицу меньше.

```python
def insert_sort(xs):
    border = len(xs) - 1
    # несортированная часть: xs[0 : border]
    # сортированная часть: xs[border : len(xs)]

    while border > 0:
        border -= 1

        print('before bubble sort pass', xs[0:border], xs[border:len(xs)])
        i = border
        while i + 1 < len(xs) and xs[i] > xs[i + 1]:
            xs[i], xs[i + 1] = xs[i + 1], xs[i]
            i += 1
        print(' after bubble sort pass', xs[0:border], xs[border:len(xs)])
    print(xs[0:border], xs[border:len(xs)])
```

Вывод программы:

```
>>> xs = [9, 3, 5, 8, 6, 7, 4, 1, 0, 2]
>>> insert_sort(xs)
before bubble sort pass [9, 3, 5, 8, 6, 7, 4, 1] [0, 2]
 after bubble sort pass [9, 3, 5, 8, 6, 7, 4, 1] [0, 2]
before bubble sort pass [9, 3, 5, 8, 6, 7, 4] [1, 0, 2]
 after bubble sort pass [9, 3, 5, 8, 6, 7, 4] [0, 1, 2]
before bubble sort pass [9, 3, 5, 8, 6, 7] [4, 0, 1, 2]
 after bubble sort pass [9, 3, 5, 8, 6, 7] [0, 1, 2, 4]
before bubble sort pass [9, 3, 5, 8, 6] [7, 0, 1, 2, 4]
 after bubble sort pass [9, 3, 5, 8, 6] [0, 1, 2, 4, 7]
before bubble sort pass [9, 3, 5, 8] [6, 0, 1, 2, 4, 7]
 after bubble sort pass [9, 3, 5, 8] [0, 1, 2, 4, 6, 7]
before bubble sort pass [9, 3, 5] [8, 0, 1, 2, 4, 6, 7]
 after bubble sort pass [9, 3, 5] [0, 1, 2, 4, 6, 7, 8]
before bubble sort pass [9, 3] [5, 0, 1, 2, 4, 6, 7, 8]
 after bubble sort pass [9, 3] [0, 1, 2, 4, 5, 6, 7, 8]
before bubble sort pass [9] [3, 0, 1, 2, 4, 5, 6, 7, 8]
 after bubble sort pass [9] [0, 1, 2, 3, 4, 5, 6, 7, 8]
before bubble sort pass [] [9, 0, 1, 2, 3, 4, 5, 6, 7, 8]
 after bubble sort pass [] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Вернёмся к программе, что можно в ней ещё оптимизировать?

```python
def insert_sort(xs):
    border = len(xs) - 1
    # несортированная часть: xs[0 : border]
    # сортированная часть: xs[border : len(xs)]

    while border > 0:
        border -= 1

        i = border
        while i + 1 < len(xs) and xs[i] > xs[i + 1]:
            xs[i], xs[i + 1] = xs[i + 1], xs[i]
            i += 1
```

Обмен двух элементов списка требует создания промежуточного кортежа
(ведь «параллельное присваивание» — это создание промежуточного кортежа
и его распаковка), а значит, четырёх присваиваний. Два присваивания
при создании кортежа из двух элементов и два при распаковке. Это можно
оптимизировать.

Во-первых, можно избавиться от кортежа:

```python
        while i + 1 < len(xs) and xs[i] > xs[i + 1]:
            xs_i_prev = xs[i]
            xs[i] = xs[i + 1]
            xs[i + 1] = xs_i_prev
            i += 1
```

Зачем тут нужна `xs_i_prev`? Если написать вот так:

```python
            xs[i] = xs[i + 1]
            xs[i + 1] = xs[i]
```

то после первого присваивания исходное значение `xs[i]` потеряется,
а его нужно сохранить в `xs[i + 1]`.

Вернёмся к примеру:

     0  1  2  3  4  5  6  7  8

    [9, 3, 5, 0, 1, 2, 4, 6, 7, 8]
         | ^  ^                     ← на этом проходе присвоили
                                               xs[2] = 0, xs[3] = 5
    [9, 3, 0, 5, 1, 2, 4, 6, 7, 8]
         |    ^  ^                  ← на этом: xs[3] = 1, xs[4] = 5
    [9, 3, 0, 1, 5, 2, 4, 6, 7, 8]
         |       ^  ^               ← на этом: xs[4] = 2, xs[5] = 5
    [9, 3, 0, 1, 2, 5, 4, 6, 7, 8]
         |          ^  ^            ← на этом: xs[5] = 4, xs[6] = 5
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]
         |             ^  ^         ← обмена не нужно

На помеченных проходах мы присваивали элементам `xs[3]`, `xs[4]`, `xs[5]`
значение `5`, хотя на следующих мы этим же элементам присваивали новое
значение.

Вернёмся к коду:

```python
        while i + 1 < len(xs) and xs[i] > xs[i + 1]:
            xs_i_prev = xs[i]
            xs[i] = xs[i + 1]
            xs[i + 1] = xs_i_prev
            i += 1
```

Значение, которое лишние разы присваивается — это `xs_i_prev`. Почему так?
Потому что в начале тела цикла оно становится `xs[i]`, перед последней
строкой — `xs[i + 1]`, но после увеличения `i` на `1` — оно снова `xs[i]`.

А значит, раз оно одно и тоже, то его можно вынести за пределы цикла:

```python
        xs_i_prev = xs[i]
        while i + 1 < len(xs) and xs_i_prev > xs[i + 1]:
            xs[i] = xs[i + 1]
            xs[i + 1] = xs_i_prev    # ???
            i += 1
```

Строчка, помеченная `???`, имеет смысл только на последней итерации. Для
наглядности поменяем местами две последние строки (учтём, что `i` увеличилось
на единицу).

```python
        xs_i_prev = xs[i]
        while i + 1 < len(xs) and xs_i_prev > xs[i + 1]:
            xs[i] = xs[i + 1]
            i += 1
            xs[i] = xs_i_prev    # ???
```

Т.е. если следующий виток цикла у нас будет — присваивание будет лишним. Т.е.
оно актуально только на последнем витке. А раз оно актуально только на последнем
витке, когда цикл завершается, его можно вынести вон. Поскольку если оно будет
вне цикла и после него, то оно по-прежнему выполнится после последнего витка,
но в непоследних витках его уже не будет.

```python
        xs_i_prev = xs[i]
        while i + 1 < len(xs) and xs_i_prev > xs[i + 1]:
            xs[i] = xs[i + 1]
            i += 1
        xs[i] = xs_i_prev
```

Т.е. здесь мы уже имеем сдвиг элементов внутри списка на одну позицию. Посмотрим
в контексте всей программы:

```python
def insert_sort(xs):
    border = len(xs) - 1
    # несортированная часть: xs[0 : border]
    # сортированная часть: xs[border : len(xs)]

    while border > 0:
        border -= 1

        i = border
        for_insert = xs[i]
        while i + 1 < len(xs) and for_insert > xs[i + 1]:
            xs[i] = xs[i + 1]
            i += 1
        xs[i] = for_insert
```

(Переменную `xs_i_prev` мы переименовали в `for_insert`.)

Т.е. эквивалентыми преобразованиями программы мы получили такой алгоритм:

* Элемент в позиции `border` — это элемент для вставки в сортированную
  часть списка.
* В сортированной части списка находим позицию для вставки, одновременно
  сдвигая элементы по одному влево.
* В результате у нас на 1 сдвинуты влево все элементы, которые не превышают
  значение `for_insert`, мы можем вставляемый элемент поставить сразу
  в нужную позицию.

Проиллюстрируем:

     0  1  2  3  4  5  6  7  8

    [9, 3, 5, 0, 1, 2, 4, 6, 7, 8]
         | ↑ ← ← ← ← ← ← ← ← ← ← ← ← Это элемент для вставки.
                                     Сохраняем его в for_insert = 5
                                     Сдвигаем не превышающие for_insert
                                     на одну позицию влево.
    [9, 3, 5, 0, 1, 2, 4, 6, 7, 8]
              ----------             Подчёркнутые сдвинуты
    [9, 3, 0, 1, 2, 4, 4, 6, 7, 8]
           ----------
    [9, 3, 0, 1, 2, 4, 4, 6, 7, 8]
                       ↑ ← ← ← ← ← ← Сюда нужно вернуть for_insert
    [9, 3, 0, 1, 2, 4, 5, 6, 7, 8]

Ещё одна мелкая оптимизация — можно избежать лишних сложений `i + 1`:

```python
def insert_sort(xs):
    border = len(xs) - 1
    # несортированная часть: xs[0 : border]
    # сортированная часть: xs[border : len(xs)]

    while border > 0:
        border -= 1

        for_insert = xs[border]
        i = border + 1
        while i < len(xs) and for_insert > xs[i]:
            xs[i - 1] = xs[i]
            i += 1
        xs[i - 1] = for_insert
```

Дополнительный материал:

* [Иллюстрация алгоритмов сортировки при помощи танцев](https://forany.xyz/a-370)
