Цикл `while`
===========
Синтаксис цикла `while` выглядит так:

    while ‹условие›:
        ‹тело цикла›

* `‹условие›` — логическое выражение, т.е. выражение, которое может быть
  истинным или ложным.
* `‹тело цикла›` — последовательность операторов с отступом

Если тело цикла состоит из одного оператора, то цикл, также как и `if`,
можно записать в одну строчку:

    while ‹условие›: ‹тело цикла›

Но так лучше не писать из стилистических соображений.

Как он выполняется:

* Вычисляется значение выражения `‹условие›`.
* Если условие ложное, цикл прерывается, `‹тело цикла›` ни разу не выполняется.
* Если условие истинноое, выполняется `‹тело цикла›`.
* И потом снова вычисляется `‹условие›`.
* Если оно ложное — цикл прерывается, если истинное, снова выполняется `‹тело
  цикла›`.
* И так далее.

Т.е. пока значение `‹условия›` истинное, поочерёдно вычисляется `‹условие›`
и выполняется тело цикла.

Сравним с `if`:

    if ‹условие›:
        ‹блок›

Блок либо выполнится, либо не выполнится.

    while ‹условие›:
        ‹блок›

Блок может выполняться много раз.

**Итерация** — однократное выполнение тела цикла.


**Пример.** Просуммировать все числа от 1 до 100.

```python
sum = 0
i = 1
while i <= 100:
    sum = sum + i
    i = i + 1
```

В переменной `i` находится очередное число. В начале оно равно `1`, затем
на каждой итерации (проходе, витке) цикла оно увеличивается на `1`. В результате
на первом витке `i` равно `1`, на втором — `i` равно `2` и т.д. Таким образом,
в переменной `i` на входе в цикл находится номер текущей итерации.

Переменная `sum` изначально равна нулю, на каждом витке цикла её содержимое
увеличивается на номер этой итерации цикла (значение переменной `i`). В итоге,
значение переменной `sum` после завершения цикла увеличится на сумму чисел
от 1 до 100. Начальным её значением было число `0`, поэтому после завершения
цикла в ней будет сумма чисел от 0 до 100.

Этот цикл обязательно завершится, т.к. до начала цикла переменная `i` хранила
значение меньше `100`, на каждом проходе цикла переменная `i` увеличивается
и поэтому рано или поздно превысит `100` — условие `i <= 100` станет ложным
и цикл прервётся.

Этот пример можно записать компактнее:

```python
sum = 0
i = 1
while i <= 100:
    sum += i
    i += 1
```

Здесь мы использовали сокращённую запись операторов присваивания. Вспомним,
что запись вида

    ‹перем›  ‹знак›=   ‹выраж›

является сокращением для

    ‹перем› = ‹перем›  ‹знак›  ‹выраж›

Вернёмся к циклу `while`. Для цикла вида

    while ‹условие›:
        ‹тело цикла›

если в теле цикла нет явных конструкций прерывания цикла (`break`, `return`),
можно быть уверенным, что после завершения цикла `‹условие›` будет ложным.

А внутри самого цикла `‹условие›` истинное.

**Пример.** Написать функцию `is_prime(n)`, проверяющую число на простоту.

```python
def is_prime(n):
    ‹проверить число на простоту›
```

Число простое, если оно больше чем `2` и делится только на себя и на единицу.
Число делится на другое, если остаток от деления равен нулю.

```python
def is_prime(n):
    ‹перебирать все числа от 2 до бесконечности,
     пока не найдётся делитель›
    ‹сравнить делитель с n›
```

Считаем, что `n` у нас не меньше `2`. Среди чисел от `2` до бесконечности
рано или поздно найдётся делитель числа `n` — для составного числа это будет
один из делителей `n`, для простого — само `n`.

```python
def is_prime(n):
    divisor = 2
    while ‹n не делится на divisor›:
        ‹увеличить divisor на 1›

    return divisor == n
```

Уточняем дальше:

```python
def is_prime(n):
    divisor = 2
    while n % divisor != 0:
        divisor += 1

    return divisor == n
```

Данная функция зациклится, если `n` будет отрицательным, нулём или единицей.
Она определена только для `n >= 2`.

Функцию можно оптимизировать, перебирая делители не до бесконечности
(фактически, до `n`), а до √n:

```python
def is_prime(n):
    divisor = 2
    while (divisor <= n**0.5) and (n % divisor != 0):
        divisor += 1

    return ‹а что тут написать?›
```

Цикл продолжается, пока `divisor <= √n` и при этом `n` не делится на `divisor`
без остатка. Соответственно, чтобы цикл прекратился, должно нарушится
хотя бы одно из условий:

* `divisor > √n`,
* `n` делится на `divisor` без остатка.

Признаком того, что число простое, является первое условие — очередной кандидат
в делители превысил `√n`.

```python
def is_prime(n):
    divisor = 2
    while (divisor <= n**0.5) and (n % divisor != 0):
        divisor += 1

    return divisor > n**0.5
```


**Пример.** Найти сумму цифр целого числа.

Нам нужно разбить число на отдельные цифры и их сложить. Разбивать число будем
справа налево: последняя цифра числа — это его остаток от деления на `10`,
все цифры, кроме последней — результат целочисленного деления на `10`.

Целочисленное деление в `Python` — это операция `//`, возвращает целую часть
частного:

    >>> 30 / 4
    7.5
    >>> 36 / 4
    9.0
    >>> 30 // 4
    7
    >>> 36 // 4
    9

Назовём функцию `sum_digits(n)`:

```python
def sum_digits(n):
    ‹найти сумму цифр›
```

Для хранения суммы заведём переменную-аккумулятор `sum`, которую на каждой
итерации будем увеличивать на величину очередной цифры. До цикла положим
в неё `0`, после завершения цикла в ней будет находиться сумма цифр.

```python
def sum_digits(n):
    sum = 0
    while ‹цифры не кончились›:
        ‹найти очередную (последнюю) цифру›
        ‹увеличить sum на очередную цифру›
        ‹отбросить последнюю цифру числа›
    return sum
```

Уточняем:

```python
def sum_digits(n):
    sum = 0
    while n != 0:
        last_digit = n % 10
        sum += last_digit
        n //= 10
    return sum
```

В предпоследней строке мы воспользовались сокращённой записью для `n = n // 10`.


Приёмы использования цикла `while`
==================================
Перебор всех значений
---------------------

**Решаемая задача.** Есть некоторая последовательность значений, нужно перебрать
их все и с каждым значением что-нибудь сделать.

**Шаблон решения:**

    ‹установка на начало›
    while ‹значения не кончились›:
        ‹сделать что-то с текущим значением›
        ‹перейти к следующему›

Под этот шаблон хорошо подходит предыдущий пример — суммирование цифр числа:

```python
def sum_digits(n):
    sum = 0
    while n != 0:
        last_digit = n % 10
        sum += last_digit
        n //= 10
    return sum
```

* Здесь `‹установки на начало›` нет, т.к. в переменной `n` уже лежит исходное
  число.
* `‹значения не кончились›` — условие `n != 0` — цифры в числе не кончились.
* `‹сделать что-то с текущим›` — две первые строчки тела цикла:
  ```python
  last_digit = n % 10
  sum += last_digit
  ```
* `‹перейти к следующему›` — `n //= 10` — отбрасывание последней цифры.

Другой **пример** с сегодняшней лекции:

```python
sum = 0
i = 1
while i <= 100:
    sum += i
    i += 1
```

* `‹установка на начало›` — `i = 1`,
* `‹значения не кончились›` — `i <= 100`,
* `‹сделать что-то с текущим›` — `sum += i` — увеличение суммы на номер витка,
* `‹перейти к следующему›` — `i += 1`.
