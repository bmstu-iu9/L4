Лекция 2. Файловый ввод-вывод
=============================

<div id="toc"></div>
<script src="toc.js"></script>

Основные понятия: файлы, пути к файлам
--------------------------------------

**Файл** — именованная область в долговременной памяти (на диске). Правила,
определяющие допустимые имена файлов, зависят от используемой файловой
системы.

Если имя файла включает как минимум один знак `.`, то часть имени
от последнего знака `.` и до конца называется **расширением.** Как правило,
расширение указывает тип содержимого файла: `.jpg` — картинка в формате JPEG,
`.txt` — текстовый файл, `.exe` — исполнимый файл ОС Windows, `.py` — исходный
текст на языке Python и т.д.

Часто интерфейс операционной системы скрывает расширения файлов, т.е. файлы
с именами `input.txt` и `program.py` будут отображаться как `input`
и `program`. Распространённая ошибка — забыть о том, что расширения скрываются
и добавить «лишнее» расширение, создав, например, текстовый файл
`input.txt.txt` — в папке он будет показываться как `input.txt`,
т.к. расширение будет скрыто. Но при этом программа на Python не сможет найти
файл `input.txt`, т.к. реально его в папке нет — есть файл с именем
`input.txt.txt`.

**Файловая система** — способ хранения данных в долговременной памяти,
использующий именованные файлы.

**Папка (каталог, «директория»)** — именованная группа файлов. Как правило,
файл находится только в одной папке. Некоторые файловые системы позволяют
одному файлу находиться в нескольких папках одновременно, но это редкая
и специфическая практика.

Папки тоже являются файлами (специального вида) и могут находиться внутри
других папок. Если папка `A` находится внутри папки `B`, то папка `B` для
папки `A` считается родительской. **Корневая папка (корневой каталог)** —
папка, у которой нет родительской.

**Путь к файлу** — строка, описывающая расположение файла в файловой системе.

У запущенной программы одна из папок файловой системы является **текущей** —
это своего рода неявная глобальная переменная.

Пути к файлам могут быть относительными и абсолютными. Относительный путь
к файлу указывается, начиная с _текущей папки,_ абсолютный путь к файлу —
начиная с _корневой папки._

В каждой папке (кроме корневой) неявно присутствуют две имени файла — ссылка
на текущую папку (записывается как одинарная точка `.`) и ссылка на родительскую
папку (записывается как две точки: `..`). Они используются, чтобы
в относительном пути ссылаться на текущую папку или на родительскую.

Путь к файлу включает в себя перечисление имён папок, в которые нужно перейти
относительно текущей или корневой папки, чтобы добраться до файла плюс в конце
само имя файла.

Если файл находится в текущей папке, то относительный путь к нему состоит
из одного имени файла.

Правила записи пути к файлу зависят от операционной системы.

### Особенности путей к файлам на Windows

На Windows компоненты пути разделяются знаками прямой `/` и обратной `\`
косой черты. Причём в интерфейсе (командная строка, элементы графического
интерфейса) обратная косая черта `\` работает всегда, прямая `/` не всегда
(из соображений совместимости по историческим причинам).

Относительный путь к файлу — перечисление имён папок с именем целевого
файла в конце, разделителем служат знаки `/` или `\`. Текущих папок
на Windows может быть несколько, у каждой буквы диска — своя текущая папка,
поэтому относительный путь на Windows может начинаться с буквы диска
и двоеточия.

Абсолютный путь к файлу начинается с разделителя папок (т.е. `/` или `\`),
который может предваряться буквой диска. Если буква диска не указана,
то подразумевается текущая буква диска.

    Абсолютные пути к файлу:
    • D:\Mazdaywik\Documents\Преподавание\L4\b-02 Файловый ввод-вывод.md
    • D:/Mazdaywik/Documents/Преподавание/L4/b-02 Файловый ввод-вывод.md
    • \Mazdaywik\Documents\Преподавание\L4\b-02 Файловый ввод-вывод.md
    • C:\Program Files\Far Manager\Far.exe
    • C:\Windows\System32\notepad.exe

    Относительные пути:
    • b-02 Файловый ввод-вывод.md
    • D:b-02 Файловый ввод-вывод.md
    • C:Far.exe
    • 2020-2021\rk1.pdf
    • ..\curricula.ref
    • ../curricula.ref

Первые три примера — файл, который я сейчас пишу, а вы сейчас читаете.

Последние два примера означают переход в родительскую папку. Абсолютный путь
для него выглядит как

    • D:/Mazdaywik/Documents/Преподавание/curricula.ref

(т.к. текущая папка — `D:\Mazdaywik\Documents\Преподавание\L4`).

В именах файлов на Windows запрещены знаки `"`, `\`, `/`, `<`, `>`, `:`, `*`,
`?`. Некоторые имена файлов зарезрвированы — `nul`, `prn`, `con`, `com1`,
`lpt1`, `aux` и ряд других — нельзя создать файл с этим именем и любым
расширением (например, `nul.txt`, `con.jpg`, `aux.py` и т.д.)

Имена файлов не чувствительны к регистру — заглавные и строчные буквы считаются
одинаковыми. Файл с именем `штукатурка.txt` можно открыть, используя имена

• `Штукатурка.txt`
• `ШТУКАТУРКА.TXT`
• `ШтукаТурка.txt`
• `штукаТУРКА.tXt`
• `ШтУкАтУрКа.TxT`

### Особенности путей к файлам на unix-подобных ОС (Linux и macOS)
  
Здесь всё проще. Разделителем компонентов в пути является только знак `/`.
Корень у файловой системы один, букв диска нету. Вместо этого для подключаемых
устройств (например, флешек) создаются отдельные папки, внутри которых
отображается содержимое устройства.

Примеры путей к файлам:

    Абсолютные пути:
    • /usr/bin/python3
    • /home/username/Documents/Таблица.docx
    • /media/My Flash Drive/Music/Моргенштерн.mp3

    Относительные пути:
    • Documents/Таблица.docx
    • ../Pictures/facepalm.jpg

На Linux в именах файлов допустимы _любые знаки,_ кроме знака `/` (т.к. он
зарезервирован для разделителя путей), в отличие от Windows, зарезервированных
имён нет (кроме `.` — ссылки на текущую папку и `..` — ссылка на родительскую).

На Linux имена файлов учитывают регистр символов — большие и маленькие буквы
считаются разными. Имена файлов `hello.txt` и `HELLO.TXT` — это имена двух
разных файлов.

На macOS регистр имён файлов, как и на Windows, не учитывается.

**Текстовый файл** — файл, хранящий в себе последовательность текстовых строк.
Строки в текстовом файле разделяются знаками перевода строки `\n`. Символы,
содержащиеся в строках, представляются байтами или последовательностями
байтов при помощи так называемых **кодировок** — наборов правил представления
символов в виде байтов.

Однобайтовые кодировки (вроде Windows-1251 для кириллицы) представляют каждый
символ в виде одного байта, поэтому поддерживают только небольшой набор символов
(не более 256 включая управляющие символы). Например, кодировка Windows-1251
для кириллицы поддерживает только кириллические и латинские буквы, цифры, набор
основных знаков пунктуации и математических знаков.

Многобайтные кодировки (UTF-8, UTF-16, UTF-32, некоторые кодировки для азиатских
языков с иероглифами) сопоставляют одному символу несколько байтов, позволяют
хранить гораздо больший набор символов. В частности, кодировка UTF-8
представляет все символы стандарта UNICODE, в частности, буквы алфавитов
большинства языков (включая иероглифы, деванагари и прочее), разнообразные
знаки пунктуации и математические знаки, эмодзи и т.д. В UTF-8 латинские буквы,
цифры и основные знаки пунктуации кодируются 1 байтом, кириллические, греческие
буквы, иврит и некоторые другие алфавиты — 2 байтами, иероглифы и эмодзи —
3 или 4 байта.

Python поддерживает работу с символами стандарта UNICODE.


Работа с файлами в Python
-------------------------
Для того, чтобы взаимодействовать с файлом, его нужно сначала _открыть_ —
создать объект файла, через который можно с ним взаимодействовать (читать
или писать).

После работы с файлом, его нужно обязательно _закрыть_ — сообщить операционной
системе, что мы с ним больше не работаем.

Несколько программ могут одновременно открыть файл для чтения и читать его.
Но если одна из программ открыла файл для записи, то другие программы, как
правило, не могут этот файл открыть, как на чтение, так и на запись (детали
поведения зависят от операционной системы).

На Windows, в частности, если файл открыт в программе, то его нельзя удалить —
получим сообщение о том, что файл занят. Если открыт файл на флешке,
то Windows не даст эту флешку безопасно извлечь.

Максимально число одновременно открытых файлов ограничено, количество зависит
от настроек операционной системы (как-то я делал опыт, на Windows не удалось
открыть более 4000 файлов одновременно).

Запись в файлы буферизуется — данные, которые записываются в файл, сначала
записываются в область оперативной памяти, т.н. «буфер», когда «буфер»
заполняется, выполняется реальна запись на диск. Буфер сбрасывается при закрытии
файла.

По этим причинам файл нужно не забывать закрывать.

### Открытие файлов
Файл открывается при помощи встроенной функции `open()`. Синтаксис:

    open(‹путь-к-файлу›, ‹режим›, encoding=‹кодировка›)

* Первый параметр (обязательный) — путь к файлу (строка).
* Второй параметр — режим. Режим может быть
  * `r` (read) — чтение текстового файла,
  * `w` (write) — перезапись текстового файла,
  * `a` (append) — дозапись в конец текстового файла,
  * `rb`, `wb`, `ab` (binary) — чтение, перезапись или дозапись двоичного
    файла.
  * Если режим файла не указан, то подразумевается `r`.
* Параметр `encoding` задаёт кодировку файла, используется для текстовых
  файлов. Рекомендуется всегда указывать кодировку `'utf-8'`. Кодировку
  можно не указывать, если в файл пишутся только символы с кодами меньше
  127 (латинские буквы, цифры, основные знаки препинания)

Примеры:

    # Текстовый файл открыт для чтения
    f1 = open('file1.txt', 'r', encoding='utf-8')

    # Тоже самое, режим 'r' подразумевается
    f2 = open('file1.txt', encoding='utf-8')

    # Здесь будет использована кодировка по умолчанию
    # (1251 на Windows, UTF-8 на Linux и macOS)
    f3 = open('file1.txt')

    # Текстовый файл открыт для перезаписи
    f4 = open('file2.txt', 'w', encoding='utf-8')

    # Текстовый файл открыт для дозаписи в конец
    f5 = open('file3.txt', 'a', encoding='utf-8')

    # Двоичный файл открыт для чтения
    f6 = open('picture.jpg', 'rb')

    # Закрытие всех файлов
    f1.close()
    f2.close()
    f3.close()
    f4.close()
    f5.close()
    f6.close()

Файл закрывается при помощи вызова метода `.close()`. Python может сам
закрывать файлы, но не всегда, поэтому `.close()` лучше вызывать явно.

### Чтение файлов
Мы будем рассматривать только чтение текстовых файлов.

Для чтения файлов используются следующие методы:

* `.read(count)` — прочитать `count` символов из файла,
* `.read()` — прочитать всё содержимое файла от текущей позиции до конца,
* `.readline()` — прочитать очередную строку из файла,
* `.readlines()` — прочитать все строки из файла, функция возвращает
  список строк.

Строки, которые возвращают `.readline()` и `.readlines()`, завершаются
символом перевода строки `\n`. Для того, чтобы эти символы стереть,
можно использовать вызов метода `.rstrip('\n')`, либо вообще `.strip()`,
если нас не интересуют ни начальные, ни конечные пробельные символы.

Сам объект текстового файла, открытого на чтение, является итератором,
который при переборе читает очередную строку (неявно вызывая `.readline()`).

**Пример** функции, которая распечатывает содержимое файла с заданным именем.

    def print_file(filename):
        fin = open(filename, 'r', encoding='utf-8')
        for line in fin:
            print(line.rstrip('\n'))
        fin.close()

Здесь мы не пользуемся методами для чтения файла, мы пользуемся тем, что
объект файла является итератором — может быть прочитан в цикле `for`. Цикл
будет перебирать все строки файла, как если бы они были прочитаны при помощи
метода `.readline()`.

В конце прочитанных строк будет находиться знак перевода строки (`\n`), кроме,
возможно, последней — она на знак `\n` может не завершаться. Поэтому для
удаления `\n` на конце мы используем метод `.rstrip('\n')`, указывая в качестве
параметра удаляемый символ.

Альтернативное решение — вручную проверять, что если строка заканчивается
на `\n`, то мы её обрезаем, иначе не трогаем. Обрезать последний символ без
проверки нельзя, т.к. в последней строке знак перевода может отсутствовать.

Если знаки `\n` не обрезать, то на печать будут выводиться лишние пустые
строки, т.к. `print()` при печати строки сам добавляет в конец знак `\n`.

Другой, более короткий способ прочитать всё содержимое файла — использовать
метод `.read()`:

    def print_file(filename):
        fin = open(filename, 'r', encoding='utf-8')
        print(fin.read())
        fin.close()

Мы при помощи метода `.read()` читаем весь файл до конца, всё содержимое
файла загружается в оперативную память в виде одной большой строки — эту
строку распечатываем при помощи `print()`. Такое решение нормально работает
только с небольшими файлами — файлами, размер которых измеряется не более
чем мегабайтами. Для гигабайтных файлов так делать не надо — памяти может
не хватить.
