Переменные-аккумуляторы
=======================

Замечание о терминологии
------------------------

Ранее я под **последовательностями** понимал всё то, что можно перебрать при помощи
цикла `for`. На самом более точная терминология такая:

* **Последовательности** — это составные объекты, которые можно индексировать
  при помощи последовательных целых чисел: списки (`list`), строки (`str`),
  кортежи (`tuple`), диапазоны (`range`). Для них для всех применим оператор
  `xs[n]`, где `n` — целое число.
* А то, что можно перебирать при помощи цикла `for` — это **итерируемые объекты.**
  Примеры: все последовательности, `dict`, `set`, `enumerate`, текстовые файлы,
  результат функций `zip` и `map`, генераторы (рассмотрим позже).

-------

Переходим к переменным-аккумуляторам.

**Переменная-аккумулятор** — это переменная, которая используется в цикле (иногда,
в рекурсии), которая «накапливает» некоторое значение.

Зачем она нужна?

Пример: суммирование элементов
------------------------------
Рассмотрим задачу. Написать функцию `sum()`, которая принимает некий итерируемый
объект с числами и находит их сумму.

```Python
sum([1, 3, 5, 7])   →   16
sum((3, 3, 3))      →   9
sum(range(10))      →   45
```

Если нам даны числа `a`, `b`, `c`, `d`, то сумма `a + b + c + d`. Как это выразить
на Python, как выразить сумму нескольких (произвольного количества элементов)
при помощи операции `+`, которая вычисляет сумму только двух элементов? Мы можем
расставить скобки так:

```
(((a + b) + c) + d)
```
Т.е. в цикле прибавлять к предыдущей сумме очередное число. Но с чего начать
само это прибавление?

Если известно, что объектов у нас как минимум один, то начать можем с самого
первого. Т.е. в примере — c `a`:
```Python
s = a
s = s + b
s = s + c
s = s + d
```
А если у нас может быть ноль объектов? Можно воспользоваться тем, что у операции
сложения нейтральным элементом является ноль: `x + 0 = 0 + x = x`. К сумме любого
числа слагаемых мы можем добавить слагаемое `0` и результат не изменится. Таким
образом, мы обеспечим себе существование как минимум одного объекта
в последовательности (в широком смысле).

```Python
a + b + c + d  =  0 + a + b + c + d  =  ((((0 + a) + b) + c) + d)

s = 0       # фиктивный первый элемент

s = s + a   # дальше к сумме прибавляем по одному элементу
s = s + b
s = s + c
s = s + d
```

Решение задачи выглядит так:

```Python
def sum(xs):
    s = 0
    for x in xs:
        s = s + x   # можно сокращённо написать s += x

    return s
```

Общий принцип
-------------
У нас есть некоторая последовательность (в широком смысле) значений, для которой
нужно выработать некоторую общую характеристику (сумму, произведение, максимум,
минимум…). Операции, которая позволяет получить из **«кучи»** значений одно — нет.
Но есть операция, которая позволяет свести **два** последовательных значения в одно.

Теперь, две ситуации:

* Если у нас исходная последовательность не пустая, то в качестве начального
  значения берём первый элемент, кладём его в **переменную-аккумулятор,** и затем
  для всех остальных элементов выполняем двухместную операцию с аккумулятором
  и очередным элементом.
* Если исходная последовательность может быть пустой, то в качестве начального
  значения берём **нейтральное** значение для данной двухместной операции
  и кладём его в **переменную-аккумулятор.** Нейтральное значение — значение,
  для которого двухместная операция в качестве результата даёт второй аргумент.
  Например: `0` для сложения, `1` для умножения, пустой список и пустая строка
  для склеивания списков и строк:
  ```Python
   0 + x   ≡   x + 0   ≡  x
   1 * x   ≡   x * 1   ≡  x
  xs + []  ≡  [] + xs  ≡  xs
  s + ' '  ≡  '' + s   ≡  s
  xs + ()  ≡  xs + ()  ≡  xs
  ```
  Потом с аккумулятором и очередным элементом выполняем двухместную операцию.
  Это же нейтральное значение будет результатом операции, если исходных элементов
  не было.

### Пример — сумма геометрической прогрессии

Найти сумму элементов геометрической прогрессии, заданных начальным членом `b0`,
знаменателем `q`, не превышающих значения `M`. Оформить решение в виде функции
`sum_geom_limit(b0, q, M)`

```Python
sum_geom_limit(1, 2, 50)    →   1 + 2 + 4 + 8 + 16 + 32 = 63
                                остановились на 32, т.к. следующий член 64 > 50
sum_geom_limit(10, 3, 400)  →   10 + 30 + 90 + 270 = 400
                                остановились на 270, поскольку следующий член 810 > 400
sum_geom_limit(100, 4, 40)  →   0, т.к. первый член уже превышает предел
```

В цикле будут порождаться новые члены геометрической прогрессии, их мы будем
прибавлять к аккумулятору. Число членов может быть пустым, поэтому начальное значение —
ноль.

Порождение геометрической прогрессии:

```Python
    b = b0
    while b <= M:
        ...
        b *= q
```

```Python
def sum_geom_limit(b0, q, M):
    b = b0
    s = 0          # переменная-аккумулятор
    while b < M:
        s += b     # прибавление числа к аккумулятору
        b *= q
    return s
```

### Пример — найти наименьшее значение в непустом списке

Можно ли эту задачу сформулировать в терминах свёртки и переменной-аккумулятора?

Мы можем определить функцию `min2(x, y)`, которая находит наименьший элемент из двух:

```Python
def min2(x, y):
    if x < y:
        return x
    else:
        return y
```

```
min([a, b, c, d])  =  min2(min2(min2(a, b), c), d)

min([2, 6, 1, 1])  =  min2(min2(min2(2, 6), 1), 1)
                                ^^^^^^^^^^
                   =  min2(min2(    2     , 1), 1)
                           ^^^^^^^^^^^^^^^^^^^
                   =  min2(         1         , 1)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                   =  1
```
Т.е. мы можем попарно брать элементы, и каждую пару заменять на минимальное значение
из пары.

Таким образом, можем воспользоваться приёмом с аккумулятором. По определению, список
на входе не пустой, поэтому начальным значением можем выбрать первый элемент:

```Python
def min(xs):
    res = xs[0]
    for x in xs[1:]:
        res = min2(res, x)

    return res
```
Решение целиком:

```Python
def min2(x, y):
    if x < y:
        return x
    else:
        return y

def min(xs):
    res = xs[0]
    for x in xs[1:]:
        res = min2(res, x)

    return res
```

Решение можно сократить — логику функции `min2()` перенести в функцию `min()`:

```Python
def min2(x, y):
    if x < y:
        return x
    else:
        return y

def min(xs):
    res = xs[0]
    for x in xs[1:]:
        #res = min2(res, x)
        if res < x:
           res = res
        else:
           res = x

    return res
```

Можно упростить тело цикла. Сначала обменяем ветки `if` и `else` местами, заменив
условие на его противоположность:

```Python
def min(xs):
    res = xs[0]
    for x in xs[1:]:
        if res >= x:
           res = x
        else:
           res = res

    return res
```

Ветка `else` становится бесполезной (т.к. ничего полезного она не делает), её можно
удалить. Всегда, когда ветка `else` ничего полезного не делает, её можно удалять.

```Python
def min(xs):
    res = xs[0]
    for x in xs[1:]:
        if res >= x:
           res = x

    return res
```

Чаще записывают не `res >= x`, а `x <= res`:

```Python
def min(xs):
    res = xs[0]
    for x in xs[1:]:
        if x <= res:
           res = x

    return res
```

По сравнению с программой, разобранной на предыдущей лекции, эта программа
эффективнее. Прошлая программа требовала выполнения `N²` операций (где `N` — длина
списка), эта — только `N` операций.

### Пример — выписать элементы списка через разделитель

Написать функцию `join`, которая принимает индексируемую последовательность
(список, кортеж, строку) и знак разделителя, и строит строку, содержащую запись
элементов через разделитель. Если исходная последовательность пустая — возвращает
пустую строку.

````
join([1, 2, 3, 4], ',')   →   '1,2,3,4'
join((4, 3, 2, 1], '+')   →   '4+3+2+1'
join('abcdef', '@')       →   'a@b@c@d@e@f'
````

Сразу есть частный случай — пустая последовательность. Исключая его, получаем,
что для непустой последовательности нужно построить строку, где элементы разделены
разделителем.

```Python
def join(xs, separator):
    if len(xs) == 0:
        return ''
    else:
        здесь мы должны склеить элементы
````

Двухместная операция — склеивание двух строк с разделителем между ними:
`x + separator + y`. Последовательность (в ветке `else`) непустая, поэтому
начальным значением будет первый элемент. Если элемент один — результат должен
быть записью элемента в виде строки, никаких разделителей приписано быть
не должно, т.к. разделитель вставляется между соседними элементами, а у него
соседей нет.

```Python
def join(xs, separator):
    if len(xs) == 0:
        return ''
    else:
        res = str(xs[0])
        for x in xs[1:]:
            res = res + separator + str(x)
        return res
````

### Пример — записать строку в обратном порядке

    reverse('hello')   →   'olleh' = 'o' + 'l' + 'l' + 'e' + 'h'

Строка получается путём сложения символов в обратном порядке.

```Python
def reverse(text):
    res = ''
    for c in text:
        res = c + res      # ВНИМАНИЕ! Приписываем в обратном порядке!
    return res
```
